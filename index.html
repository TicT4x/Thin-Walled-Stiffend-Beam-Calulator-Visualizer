<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dünnwandige Profile - Unit 3 Visualisierung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f3f4f6; }
        canvas { background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); cursor: crosshair; }
        .input-group label { font-size: 0.85rem; font-weight: 600; color: #374151; }
        .input-group input, .input-group select { width: 100%; padding: 0.5rem; margin-top: 0.25rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.9rem; }
        .panel-header { font-size: 1.1rem; font-weight: bold; color: #1f2937; margin-bottom: 1rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
        .result-val { font-family: 'Courier New', Courier, monospace; font-weight: bold; color: #2563eb; }
        /* Animation für Button Feedback */
        @keyframes flash { 0% { background-color: #2563eb; } 50% { background-color: #4f46e5; } 100% { background-color: #2563eb; } }
        .btn-clicked { animation: flash 0.2s ease-in-out; }
        
        /* Tooltip Style */
        #tooltip {
            position: fixed; /* Fixed damit es über allem schwebt */
            background: rgba(17, 24, 39, 0.95); /* Slate-900 mit Transparenz */
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none; /* Maus ignoriert das Tooltip, klickt drunter durch */
            display: none;
            z-index: 1000;
            white-space: pre-line;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Tooltip Element -->
    <div id="tooltip"></div>

    <!-- Header -->
    <header class="bg-slate-800 text-white p-4 shadow-md flex justify-between items-center shrink-0">
        <div>
            <h1 class="text-xl font-bold">Thin-Walled Stiffened Beam (Unit 3)</h1>
            <p class="text-sm text-slate-300">Schubfluss & Axialkräfte in Einzellern (Boom-Idealisierung)</p>
        </div>
        <div class="text-right text-xs text-slate-400">
            <p>Rot = Zug (+), Blau = Druck (-)</p>
            <p>Gelbe Boxen = Schubfluss-Verlauf (Höhe = Betrag)</p>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Sidebar Controls -->
        <aside class="w-80 bg-white shadow-lg overflow-y-auto p-4 shrink-0 z-10 border-r border-gray-200">
            
            <!-- Geometry Section -->
            <div class="mb-6">
                <h3 class="panel-header">1. Geometrie (Querschnitt)</h3>
                <div class="input-group mb-3">
                    <label>Profilform</label>
                    <select id="shapeType" onchange="updateUI()">
                        <option value="rect">Rechteckkasten</option>
                        <option value="circle">Kreisrohr</option>
                        <option value="ellipse">Elliptisches Rohr</option>
                    </select>
                </div>
                
                <div id="dims-rect" class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>Breite w [mm]</label>
                        <input type="number" id="dimW" value="1000" step="10">
                    </div>
                    <div class="input-group">
                        <label>Höhe h [mm]</label>
                        <input type="number" id="dimH" value="500" step="10">
                    </div>
                </div>

                <div id="dims-circle" class="input-group mb-3 hidden">
                    <label>Radius R [mm]</label>
                    <input type="number" id="dimR" value="400" step="10">
                </div>

                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>Anzahl Booms</label>
                        <input type="number" id="numBooms" value="16" min="4" step="1">
                    </div>
                    <div class="input-group">
                        <label>Boom Fläche B [mm²]</label>
                        <input type="number" id="boomArea" value="200" step="10">
                    </div>
                </div>
            </div>

            <!-- Loads Section -->
            <div class="mb-6">
                <h3 class="panel-header">2. Belastung (Schnittlasten)</h3>
                
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>Kraft Sy [N] (Seite)</label>
                        <input type="number" id="loadSy" value="0" step="100">
                    </div>
                    <div class="input-group">
                        <label>Kraft Sz [N] (Vertikal)</label>
                        <input type="number" id="loadSz" value="10000" step="100">
                    </div>
                </div>

                <div class="input-group mb-3">
                    <label>Zusatz-Torsion Mx [Nm]</label>
                    <input type="number" id="loadMx" value="0" step="10">
                    <p class="text-xs text-gray-500 mt-1">Reines Moment (zusätzlich zum Hebelarm)</p>
                </div>

                <h4 class="text-sm font-bold text-gray-600 mt-4 mb-2">Kraftangriffspunkt (Relativ zum Schwerpunkt)</h4>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>y_F [mm]</label>
                        <input type="number" id="posFy" value="0" step="10">
                    </div>
                    <div class="input-group">
                        <label>z_F [mm]</label>
                        <input type="number" id="posFz" value="0" step="10">
                    </div>
                </div>

                <h4 class="text-sm font-bold text-gray-600 mt-4 mb-2">Biegemomente (Für Axialspannung)</h4>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>My [Nm]</label>
                        <input type="number" id="momentMy" value="5000" step="100">
                    </div>
                    <div class="input-group">
                        <label>Mz [Nm]</label>
                        <input type="number" id="momentMz" value="0" step="100">
                    </div>
                </div>
            </div>

            <div class="mb-6">
                <button id="updateBtn" onclick="handleUpdateClick()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition shadow-md">
                    Aktualisieren
                </button>
            </div>

        </aside>

        <!-- Visualization Area -->
        <main class="flex-1 flex flex-col relative bg-gray-50">
            <div class="absolute top-4 left-4 bg-white/95 p-3 rounded-lg shadow-md text-xs z-10 pointer-events-none border border-gray-200">
                <div class="font-bold mb-1 text-sm text-gray-800">Koordinatensystem</div>
                <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-black"></span> y: nach rechts</div>
                <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-black"></span> z: nach oben</div>
                <div class="mt-2 text-gray-500 border-t pt-1">Ursprung (0,0) = Flächenschwerpunkt</div>
            </div>

            <div class="flex-1 p-4 flex justify-center items-center overflow-hidden" id="canvas-container">
                <canvas id="beamCanvas"></canvas>
            </div>

            <!-- Results Footer -->
            <div class="h-auto min-h-[180px] bg-white border-t-2 border-gray-200 p-5 overflow-y-auto shrink-0 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                <h3 class="font-bold text-gray-800 mb-3 text-lg">Berechnungsergebnisse</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 text-sm">
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Trägheitsmomente</p>
                        <div class="flex justify-between"><span>Iyy:</span> <span id="resIyy" class="result-val">0</span> <span class="text-gray-400">mm⁴</span></div>
                        <div class="flex justify-between"><span>Izz:</span> <span id="resIzz" class="result-val">0</span> <span class="text-gray-400">mm⁴</span></div>
                        <div class="flex justify-between"><span>Iyz:</span> <span id="resIyz" class="result-val">0</span> <span class="text-gray-400">mm⁴</span></div>
                    </div>
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Schubmittelpunkt (SC)</p>
                        <div class="flex justify-between"><span>y_s:</span> <span id="resYs" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                        <div class="flex justify-between"><span>z_s:</span> <span id="resZs" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                    </div>
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Lastsituation</p>
                        <div class="flex justify-between"><span>dy (F zu SC):</span> <span id="resDy" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                        <div class="flex justify-between"><span>dz (F zu SC):</span> <span id="resDz" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                        <div class="flex justify-between"><span>Torsion (Gesamt):</span> <span id="resTors" class="result-val">0</span> <span class="text-gray-400">Nm</span></div>
                    </div>
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Spitzenwerte</p>
                        <div class="flex justify-between"><span>Max q:</span> <span id="resMaxQ" class="result-val">0</span> <span class="text-gray-400">N/mm</span></div>
                        <div class="flex justify-between"><span>Max Zug:</span> <span id="resMaxTens" class="result-val text-red-600">0</span> <span class="text-gray-400">N</span></div>
                        <div class="flex justify-between"><span>Max Druck:</span> <span id="resMaxComp" class="result-val text-blue-600">0</span> <span class="text-gray-400">N</span></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State ---
        const canvas = document.getElementById('beamCanvas');
        const ctx = canvas.getContext('2d');
        let geometry = { 
            booms: [], 
            shearFlows: [],
            shearFlowPolygons: [], // New: Store polygons for hit detection
            Iyy: 0, Izz: 0, Iyz: 0, 
            centroid: {y:0, z:0}, 
            areaEnclosed: 0 
        };
        // Store scaling parameters for hit detection
        let lastDrawParams = { scale: 1, cx: 0, cy: 0 };
        
        // --- Initialization ---
        window.addEventListener('resize', () => {
             requestAnimationFrame(resizeCanvas);
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            updateUI();
            resizeCanvas();
        });

        // --- Mouse Interaction for Tooltip ---
        canvas.addEventListener('mousemove', (e) => {
            // Falls keine Geometrie da ist, abbrechen
            if (!geometry.booms.length) return;

            const rect = canvas.getBoundingClientRect();
            // Mausposition im Canvas
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Transformation rekonstruieren
            const { scale, cx, cy } = lastDrawParams;
            const toX = (val) => cx + val * scale;
            const toY = (val) => cy - val * scale;

            let hit = null;

            // 1. Booms prüfen (Priorität)
            for(const b of geometry.booms) {
                const bx = toX(b.y_bar);
                const by = toY(b.z_bar);
                const dist = Math.sqrt((x - bx)**2 + (y - by)**2);
                
                if (dist < 12) { // 12px Toleranzradius
                    hit = { type: 'boom', data: b };
                    break; 
                }
            }

            // 2. Schubfluss-Boxen prüfen (Point in Polygon)
            if (!hit && geometry.shearFlowPolygons) {
                for(const poly of geometry.shearFlowPolygons) {
                    if (pointInPoly(x, y, poly.points)) {
                        hit = { type: 'web', data: poly.data, startId: poly.startId, endId: poly.endId };
                        break;
                    }
                }
            }
            
            // Fallback: Hautfelder Linie (falls Boxen sehr klein)
            if (!hit) {
                for(const sf of geometry.shearFlows) {
                    const b1 = geometry.booms[sf.startBoom];
                    const b2 = geometry.booms[sf.endBoom];
                    const x1 = toX(b1.y_bar);
                    const y1 = toY(b1.z_bar);
                    const x2 = toX(b2.y_bar);
                    const y2 = toY(b2.z_bar);

                    const dist = distToSegment(x, y, x1, y1, x2, y2);
                    if (dist < 8) { 
                        hit = { type: 'web', data: sf, startId: b1.id, endId: b2.id };
                        break;
                    }
                }
            }

            // Tooltip anzeigen
            const tip = document.getElementById('tooltip');
            if (hit) {
                tip.style.display = 'block';
                tip.style.left = (e.clientX + 15) + 'px';
                tip.style.top = (e.clientY + 15) + 'px';

                if (hit.type === 'boom') {
                    const force = hit.data.force;
                    const stress = hit.data.sigma;
                    const colorClass = force >= 0 ? 'text-red-400' : 'text-blue-400';
                    const label = force >= 0 ? 'Zug' : 'Druck';
                    
                    tip.innerHTML = `
                        <div class="font-bold border-b border-gray-600 mb-1 pb-1">Boom ID: ${hit.data.id}</div>
                        <div>Kraft P: <span class="${colorClass} font-bold">${force.toFixed(1)} N</span> (${label})</div>
                        <div>Spannung σ: ${stress.toFixed(2)} N/mm²</div>
                        <div class="text-gray-400 text-xs mt-1">Koord: (${hit.data.y.toFixed(0)}, ${hit.data.z.toFixed(0)})</div>
                    `;
                } else if (hit.type === 'web') {
                    const q = hit.data.total;
                    tip.innerHTML = `
                        <div class="font-bold border-b border-gray-600 mb-1 pb-1">Hautfeld ${hit.startId} → ${hit.endId}</div>
                        <div>Schubfluss q: <span class="text-yellow-400 font-bold">${q.toFixed(2)} N/mm</span></div>
                        <div class="text-xs text-gray-400">Basisanteil q_b: ${hit.data.val_b.toFixed(2)}</div>
                    `;
                }
            } else {
                tip.style.display = 'none';
            }
        });

        // --- Helper: Point in Polygon (Ray Casting) ---
        function pointInPoly(x, y, vs) {
            // ray-casting algorithm based on
            // https://github.com/substack/point-in-polygon
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].x, yi = vs[i].y;
                const xj = vs[j].x, yj = vs[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Hilfsfunktion: Abstand Punkt zu Linie
        function distToSegment(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1)**2 + (y2 - y1)**2;
            if (l2 === 0) return Math.sqrt((px - x1)**2 + (py - y1)**2);
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt((px - (x1 + t * (x2 - x1)))**2 + (py - (y1 + t * (y2 - y1)))**2);
        }

        function handleUpdateClick() {
            const btn = document.getElementById('updateBtn');
            btn.classList.add('btn-clicked');
            setTimeout(() => btn.classList.remove('btn-clicked'), 200);
            calculateAndDraw();
        }

        function updateUI() {
            const type = document.getElementById('shapeType').value;
            if (type === 'rect' || type === 'ellipse') {
                document.getElementById('dims-rect').classList.remove('hidden');
                document.getElementById('dims-circle').classList.add('hidden');
            } else {
                document.getElementById('dims-rect').classList.add('hidden');
                document.getElementById('dims-circle').classList.remove('hidden');
            }
            setTimeout(calculateAndDraw, 10);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            if(container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                calculateAndDraw();
            }
        }

        // --- Helper for Safer Inputs ---
        function safeFloat(id, defaultVal = 0) {
            const el = document.getElementById(id);
            if (!el) return defaultVal;
            const val = parseFloat(el.value);
            return isNaN(val) ? defaultVal : val;
        }

        function safeInt(id, defaultVal = 4) {
            const el = document.getElementById(id);
            if (!el) return defaultVal;
            const val = parseInt(el.value);
            return isNaN(val) ? defaultVal : val;
        }

        // --- Core Calculation Logic ---

        function calculateAndDraw() {
            try {
                const inputs = getInputs();
                generateGeometry(inputs);
                if (geometry.booms.length < 3) return; 

                calculateSectionProperties();
                const shearCenter = calculateShearCenter();
                calculateAxialForces(inputs.My, inputs.Mz);
                calculateShearFlows(inputs);

                const leverY = inputs.posFy - shearCenter.y;
                const leverZ = inputs.posFz - shearCenter.z;
                const torsionTotal = (inputs.Sz * leverY) - (inputs.Sy * leverZ) + inputs.Mx;

                updateResults(shearCenter, leverY, leverZ, torsionTotal);
                draw(inputs, shearCenter);
            } catch (e) {
                console.error("Berechnungsfehler:", e);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "red";
                ctx.font = "14px Arial";
                ctx.fillText("Fehler in der Berechnung. Bitte Werte prüfen.", 20, 30);
            }
        }

        function getInputs() {
            return {
                type: document.getElementById('shapeType').value,
                w: safeFloat('dimW', 1000),
                h: safeFloat('dimH', 500),
                r: safeFloat('dimR', 400),
                n: safeInt('numBooms', 8),
                boomArea: safeFloat('boomArea', 200),
                Sy: safeFloat('loadSy', 0),
                Sz: safeFloat('loadSz', 10000),
                Mx: safeFloat('loadMx', 0) * 1000, 
                posFy: safeFloat('posFy', 0),
                posFz: safeFloat('posFz', 0),
                My: safeFloat('momentMy', 5000) * 1000, 
                Mz: safeFloat('momentMz', 0) * 1000, 
            };
        }

        function generateGeometry(inputs) {
            geometry.booms = [];
            
            if (inputs.type === 'rect') {
                const w = inputs.w;
                const h = inputs.h;
                if (w <= 0 || h <= 0) return;

                const N = Math.max(4, inputs.n);
                let segments = [1, 1, 1, 1]; 
                let currentTotal = 4;
                const lengths = [w, h, w, h];
                
                while(currentTotal < N) {
                    let maxLen = -1;
                    let bestSide = 0;
                    for(let i=0; i<4; i++) {
                        let segLen = lengths[i] / segments[i];
                        if(segLen > maxLen) {
                            maxLen = segLen;
                            bestSide = i;
                        }
                    }
                    segments[bestSide]++;
                    currentTotal++;
                }
                
                const addPoints = (startX, startY, endX, endY, count) => {
                    const dx = (endX - startX) / count;
                    const dy = (endY - startY) / count;
                    
                    for(let i=0; i<count; i++) {
                        geometry.booms.push({
                            y: startX + i*dx,
                            z: startY + i*dy,
                            area: inputs.boomArea,
                            id: geometry.booms.length + 1
                        });
                    }
                };
                addPoints(w/2, h/2, -w/2, h/2, segments[0]);
                addPoints(-w/2, h/2, -w/2, -h/2, segments[1]);
                addPoints(-w/2, -h/2, w/2, -h/2, segments[2]);
                addPoints(w/2, -h/2, w/2, h/2, segments[3]);

            } else if (inputs.type === 'ellipse') {
                const w = inputs.w;
                const h = inputs.h;
                if (w <= 0 || h <= 0) return;
                const a = w / 2;
                const b = h / 2;
                const dTheta = (2 * Math.PI) / inputs.n;
                
                for (let i = 0; i < inputs.n; i++) {
                    const theta = (Math.PI / 2) + i * dTheta;
                    geometry.booms.push({
                        y: a * Math.cos(theta), 
                        z: b * Math.sin(theta),
                        area: inputs.boomArea,
                        id: i + 1
                    });
                }
            } else { // Circle
                const r = inputs.r;
                if (r <= 0) return;
                const dTheta = (2 * Math.PI) / inputs.n;
                for (let i = 0; i < inputs.n; i++) {
                    const theta = (Math.PI / 2) + i * dTheta;
                    geometry.booms.push({
                        y: r * Math.cos(theta), 
                        z: r * Math.sin(theta),
                        area: inputs.boomArea,
                        id: i + 1
                    });
                }
            }

            // Polygon-Fläche
            let polyArea = 0;
            const n = geometry.booms.length;
            for (let i = 0; i < n; i++) {
                const b1 = geometry.booms[i];
                const b2 = geometry.booms[(i + 1) % n];
                polyArea += (b1.y * b2.z - b1.z * b2.y);
            }
            geometry.areaEnclosed = Math.abs(polyArea) / 2;
        }

        function calculateSectionProperties() {
            let sumAy = 0, sumAz = 0, sumA = 0;
            geometry.booms.forEach(b => {
                sumA += b.area;
                sumAy += b.area * b.y;
                sumAz += b.area * b.z;
            });
            const cy = sumAy / (sumA || 1); 
            const cz = sumAz / (sumA || 1);
            geometry.centroid = { y: cy, z: cz };

            let Iyy = 0, Izz = 0, Iyz = 0;
            geometry.booms.forEach(b => {
                b.y_bar = b.y - cy;
                b.z_bar = b.z - cz;
                Iyy += b.area * b.z_bar * b.z_bar;
                Izz += b.area * b.y_bar * b.y_bar;
                Iyz += b.area * b.y_bar * b.z_bar;
            });
            geometry.Iyy = Iyy;
            geometry.Izz = Izz;
            geometry.Iyz = Iyz;
        }

        function calculateAxialForces(My, Mz) {
            const denom = geometry.Iyy * geometry.Izz - geometry.Iyz * geometry.Iyz;
            if (Math.abs(denom) < 1e-9) return; 

            geometry.booms.forEach(b => {
                const termZ = (My * geometry.Izz - Mz * geometry.Iyz) / denom;
                const termY = (Mz * geometry.Iyy - My * geometry.Iyz) / denom;
                const sigma = termZ * b.z_bar + termY * b.y_bar;
                b.sigma = sigma;
                b.force = sigma * b.area;
            });
        }

        function getDeltaQ(Sy, Sz, boom) {
            const denom = geometry.Iyy * geometry.Izz - geometry.Iyz * geometry.Iyz;
            if (Math.abs(denom) < 1e-9) return 0;
            const factorZ = (Sz * geometry.Iyy - Sy * geometry.Iyz);
            const factorY = (Sy * geometry.Izz - Sz * geometry.Iyz);
            const val = - (factorZ * boom.z_bar + factorY * boom.y_bar) * (boom.area / denom);
            return val;
        }

        function calculateShearFlows(inputs) {
            const Sy = inputs.Sy;
            const Sz = inputs.Sz;
            const Mx = inputs.Mx;

            let q_current = 0;
            geometry.shearFlows = []; 

            for (let i = 0; i < geometry.booms.length; i++) {
                const boom = geometry.booms[i];
                const deltaQ = getDeltaQ(Sy, Sz, boom);
                q_current += deltaQ;
                
                geometry.shearFlows.push({
                    val_b: q_current, 
                    startBoom: i,
                    endBoom: (i + 1) % geometry.booms.length
                });
            }

            let M_qb = 0;
            geometry.shearFlows.forEach(sf => {
                const b1 = geometry.booms[sf.startBoom];
                const b2 = geometry.booms[sf.endBoom];
                const twoA_i = (b1.y_bar * b2.z_bar - b1.z_bar * b2.y_bar); 
                M_qb += sf.val_b * twoA_i; 
            });

            const M_ext = Sz * inputs.posFy - Sy * inputs.posFz + Mx;
            let qs0 = 0;
            if (geometry.areaEnclosed > 0) {
                qs0 = (M_ext - M_qb) / (2 * geometry.areaEnclosed);
            }

            geometry.shearFlows.forEach(sf => {
                sf.total = sf.val_b + qs0;
            });
        }

        function calculateShearCenter() {
            const denom = geometry.Iyy * geometry.Izz - geometry.Iyz * geometry.Iyz;
            if (Math.abs(denom) < 1e-9) return {y:0, z:0};
            
            const solveUnitLoad = (Sy_u, Sz_u) => {
                let q_curr = 0;
                let M_qb_u = 0;
                let qb_int = 0; 
                let perim = 0;
                for (let i = 0; i < geometry.booms.length; i++) {
                    const b1 = geometry.booms[i];
                    const b2 = geometry.booms[(i + 1) % geometry.booms.length];
                    const len = Math.sqrt(Math.pow(b2.y - b1.y, 2) + Math.pow(b2.z - b1.z, 2));
                    const dQ = getDeltaQ(Sy_u, Sz_u, b1);
                    q_curr += dQ;
                    const twoA = (b1.y_bar * b2.z_bar - b1.z_bar * b2.y_bar);
                    M_qb_u += q_curr * twoA;
                    perim += len;
                    qb_int += q_curr * len;
                }
                const qs0_u = -qb_int / (perim || 1);
                const M_int_u = M_qb_u + 2 * geometry.areaEnclosed * qs0_u;
                return M_int_u;
            };
            const ys = solveUnitLoad(0, 1);
            const neg_zs = solveUnitLoad(1, 0);
            return { y: ys, z: -neg_zs };
        }

        // --- Visualization & Drawing ---

        function draw(inputs, sc) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            geometry.shearFlowPolygons = []; // Reset visual Hitboxes

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            let shapeDim = 1000;
            if (inputs.type === 'rect' || inputs.type === 'ellipse') {
                shapeDim = Math.max(inputs.w, inputs.h);
            } else {
                shapeDim = inputs.r * 2;
            }
            if (shapeDim <= 0) shapeDim = 1000;

            const scale = Math.min(canvas.width, canvas.height) / (shapeDim * 1.6);
            lastDrawParams = { scale, cx, cy };

            const toX = (y) => cx + y * scale;
            const toY = (z) => cy - z * scale;

            // 1. Draw Skin
            ctx.beginPath();
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            geometry.booms.forEach((b, i) => {
                const next = geometry.booms[(i + 1) % geometry.booms.length];
                ctx.moveTo(toX(b.y_bar), toY(b.z_bar));
                ctx.lineTo(toX(next.y_bar), toY(next.z_bar));
            });
            ctx.stroke();

            // 2. Draw Shear Flows (Box Diagram)
            let maxQ = 0;
            geometry.shearFlows.forEach(s => maxQ = Math.max(maxQ, Math.abs(s.total)));
            if (maxQ === 0) maxQ = 0.001; 
            const maxPxHeight = 50;

            // First Pass: Calculate all outer points to connect them continuously
            const segments = geometry.shearFlows.map(sf => {
                const b1 = geometry.booms[sf.startBoom];
                const b2 = geometry.booms[sf.endBoom];
                const x1 = toX(b1.y_bar);
                const y1 = toY(b1.z_bar);
                const x2 = toX(b2.y_bar);
                const y2 = toY(b2.z_bar);
                
                let dx = x2 - x1;
                let dy = y2 - y1;
                const len = Math.sqrt(dx*dx + dy*dy);
                let nx = -dy / len;
                let ny = dx / len;

                // Check direction (outward)
                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;
                const cx_vec = mx - cx;
                const cy_vec = my - cy;
                if (cx_vec * nx + cy_vec * ny < 0) { nx = -nx; ny = -ny; }

                const h = (Math.abs(sf.total) / maxQ) * maxPxHeight;
                
                return {
                    sf, x1, y1, x2, y2, nx, ny, h,
                    out1: { x: x1 + nx * h, y: y1 + ny * h },
                    out2: { x: x2 + nx * h, y: y2 + ny * h },
                    len, dx, dy
                };
            });

            // Second Pass: Draw and Fill gaps
            segments.forEach((seg, i) => {
                if (Math.abs(seg.sf.total) < 0.001) return;

                // Main Box
                const polyPoints = [
                    {x: seg.x1, y: seg.y1},
                    {x: seg.x2, y: seg.y2},
                    {x: seg.out2.x, y: seg.out2.y},
                    {x: seg.out1.x, y: seg.out1.y}
                ];

                // Store for hit detection
                geometry.shearFlowPolygons.push({
                    points: polyPoints,
                    data: seg.sf,
                    startId: geometry.booms[seg.sf.startBoom].id,
                    endId: geometry.booms[seg.sf.endBoom].id
                });

                ctx.beginPath();
                ctx.fillStyle = 'rgba(234, 179, 8, 0.4)';
                ctx.strokeStyle = 'rgba(234, 179, 8, 1.0)';
                ctx.lineWidth = 1;
                ctx.moveTo(polyPoints[0].x, polyPoints[0].y);
                for(let k=1; k<4; k++) ctx.lineTo(polyPoints[k].x, polyPoints[k].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Arrow on skin
                const isPos = seg.sf.total >= 0;
                let adx = seg.dx / seg.len;
                let ady = seg.dy / seg.len;
                if (!isPos) { adx = -adx; ady = -ady; }
                const arrowLen = 14; 
                const mx = (seg.x1 + seg.x2)/2;
                const my = (seg.y1 + seg.y2)/2;

                ctx.beginPath();
                ctx.strokeStyle = '#eab308';
                ctx.lineWidth = 2;
                ctx.moveTo(mx - adx * arrowLen/2, my - ady * arrowLen/2);
                ctx.lineTo(mx + adx * arrowLen/2, my + ady * arrowLen/2);
                ctx.stroke();

                const headSize = 7;
                const tipX = mx + adx * arrowLen/2;
                const tipY = my + ady * arrowLen/2;
                const pdx = -ady; 
                const pdy = adx;
                ctx.beginPath();
                ctx.fillStyle = '#eab308';
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(tipX - adx*headSize + pdx*headSize*0.5, tipY - ady*headSize + pdy*headSize*0.5);
                ctx.lineTo(tipX - adx*headSize - pdx*headSize*0.5, tipY - ady*headSize - pdy*headSize*0.5);
                ctx.fill();
            });

            // 3. Draw Booms
            let maxForce = 0;
            geometry.booms.forEach(b => maxForce = Math.max(maxForce, Math.abs(b.force)));
            if (maxForce === 0) maxForce = 1;

            geometry.booms.forEach(b => {
                const x = toX(b.y_bar);
                const y = toY(b.z_bar);
                const isTen = b.force >= 0;
                const radius = 3 + (Math.abs(b.force) / maxForce) * 9;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = isTen ? '#ef4444' : '#3b82f6';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                if (radius > 6) {
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(b.id, x, y);
                }
            });

            // 4. Draw Center & SC
            drawCross(toX(0), toY(0), '#000000', 'CG'); 
            drawCross(toX(sc.y), toY(sc.z), '#10b981', 'SC'); 

            // 5. Draw Force
            const fX = toX(inputs.posFy);
            const fY = toY(inputs.posFz);
            
            ctx.beginPath();
            ctx.arc(fX, fY, 5, 0, 2*Math.PI);
            ctx.fillStyle = '#9333ea';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.stroke();

            const forceMag = Math.sqrt(inputs.Sy*inputs.Sy + inputs.Sz*inputs.Sz);
            if (forceMag > 1) {
                const vecLenPx = 60; 
                const nSy = inputs.Sy / forceMag;
                const nSz = inputs.Sz / forceMag;
                const tipX = fX + nSy * vecLenPx;
                const tipY = fY - nSz * vecLenPx;
                drawArrow(ctx, fX, fY, tipX, tipY, '#9333ea', 3);
                ctx.fillStyle = '#9333ea';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('F', tipX + 5, tipY);
            }
        }

        function drawCross(x, y, color, label) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.moveTo(x-6, y); ctx.lineTo(x+6, y);
            ctx.moveTo(x, y-6); ctx.lineTo(x, y+6);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.font = 'bold 11px Arial';
            ctx.fillText(label, x+5, y-5);
        }

        function drawArrow(ctx, fromx, fromy, tox, toy, color, width) {
            const headlen = 12;
            const dx = tox - fromx;
            const dy = toy - fromy;
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.stroke();
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.fill();
        }

        function updateResults(sc, dy, dz, tTot) {
            const fmt = (v, d=1) => (isNaN(v) ? 0 : v).toFixed(d);
            const sci = (v) => (isNaN(v) ? 0 : v).toExponential(2);
            document.getElementById('resIyy').textContent = sci(geometry.Iyy);
            document.getElementById('resIzz').textContent = sci(geometry.Izz);
            document.getElementById('resIyz').textContent = sci(geometry.Iyz);
            document.getElementById('resYs').textContent = fmt(sc.y);
            document.getElementById('resZs').textContent = fmt(sc.z);
            document.getElementById('resDy').textContent = fmt(dy);
            document.getElementById('resDz').textContent = fmt(dz);
            document.getElementById('resTors').textContent = fmt(tTot / 1000, 1);
            let maxQ = 0, maxTen = 0, maxComp = 0;
            if(geometry.shearFlows.length) maxQ = Math.max(...geometry.shearFlows.map(s => Math.abs(s.total)));
            if(geometry.booms.length) {
                maxTen = Math.max(0, ...geometry.booms.map(b => b.force));
                maxComp = Math.min(0, ...geometry.booms.map(b => b.force));
            }
            document.getElementById('resMaxQ').textContent = fmt(maxQ, 2);
            document.getElementById('resMaxTens').textContent = fmt(maxTen, 0);
            document.getElementById('resMaxComp').textContent = fmt(maxComp, 0);
        }
    </script>
</body>
</html>

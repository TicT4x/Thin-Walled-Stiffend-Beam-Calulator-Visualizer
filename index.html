<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dünnwandige Profile - Unit 3 Visualisierung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f3f4f6; }
        canvas { background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); cursor: grab; }
        canvas:active { cursor: grabbing; }
        .input-group label { font-size: 0.85rem; font-weight: 600; color: #374151; }
        .input-group input, .input-group select { width: 100%; padding: 0.5rem; margin-top: 0.25rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.9rem; }
        .panel-header { font-size: 1.1rem; font-weight: bold; color: #1f2937; margin-bottom: 1rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
        .result-val { font-family: 'Courier New', Courier, monospace; font-weight: bold; color: #2563eb; }
        /* Animation für Button Feedback */
        @keyframes flash { 0% { background-color: #2563eb; } 50% { background-color: #4f46e5; } 100% { background-color: #2563eb; } }
        .btn-clicked { animation: flash 0.2s ease-in-out; }
        
        /* Tooltip Style */
        #tooltip {
            position: fixed; /* Fixed damit es über allem schwebt */
            background: rgba(17, 24, 39, 0.95); /* Slate-900 mit Transparenz */
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none; /* Maus ignoriert das Tooltip, klickt drunter durch */
            display: none;
            z-index: 1000;
            white-space: pre-line;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        /* Reset Button Overlay */
        .canvas-overlay-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            z-index: 20;
            transition: all 0.2s;
        }
        .canvas-overlay-btn:hover {
            background: #f9fafb;
            color: #2563eb;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Tooltip Element -->
    <div id="tooltip"></div>

    <!-- Header -->
    <header class="bg-slate-800 text-white p-4 shadow-md flex justify-between items-center shrink-0">
        <div>
            <h1 class="text-xl font-bold">Thin-Walled Stiffened Beam (Unit 3)</h1>
            <p class="text-sm text-slate-300">Schubfluss & Axialkräfte in Einzellern & offenen Profilen</p>
        </div>
        <div class="text-right text-xs text-slate-400">
            <p>Rot = Zug (+), Blau = Druck (-)</p>
            <p>Gelbe Boxen = Schubfluss-Verlauf (Höhe = Betrag)</p>
            <p class="opacity-75 mt-1">Mausrad: Zoom | Ziehen: Bewegen</p>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Sidebar Controls -->
        <aside class="w-80 bg-white shadow-lg overflow-y-auto p-4 shrink-0 z-10 border-r border-gray-200">
            
            <!-- Geometry Section -->
            <div class="mb-6">
                <h3 class="panel-header">1. Geometrie (Querschnitt)</h3>
                <div class="input-group mb-3">
                    <label>Profil-Kategorie</label>
                    <select id="shapeType" onchange="updateUI(true)">
                        <option value="closed">Geschlossenes Profil</option>
                        <option value="open">Offenes Profil</option>
                    </select>
                </div>

                <!-- Sub-Selection for Closed -->
                <div id="sub-closed" class="input-group mb-3">
                    <label>Form</label>
                    <select id="closedType" onchange="updateUI(true)">
                        <option value="rect">Rechteckkasten</option>
                        <option value="circle">Kreisrohr</option>
                        <option value="ellipse">Elliptisches Rohr</option>
                    </select>
                </div>

                <!-- Sub-Selection for Open -->
                <div id="sub-open" class="input-group mb-3 hidden">
                    <label>Form</label>
                    <select id="openType" onchange="updateUI(true)">
                        <option value="I">I-Profil</option>
                        <option value="C">C-Profil (U)</option>
                        <option value="T">T-Profil</option>
                        <option value="L">L-Profil (Winkel)</option>
                        <option value="Z">Z-Profil</option>
                    </select>
                </div>
                
                <!-- Dynamic Dimensions -->
                <div id="dims-container" class="grid grid-cols-2 gap-2 mb-3">
                    <!-- Wird per JS befüllt -->
                </div>

                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>Booms (Gesamt)</label>
                        <input type="number" id="numBooms" value="16" min="4" step="1" onblur="checkEmpty(this)">
                    </div>
                    <div class="input-group">
                        <label>Boom Fläche B [mm²]</label>
                        <input type="number" id="boomArea" value="200" step="10" onblur="checkEmpty(this)">
                    </div>
                </div>
            </div>

            <!-- Loads Section -->
            <div class="mb-6">
                <h3 class="panel-header">2. Belastung (Schnittlasten)</h3>
                
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>Kraft Sy [N] (Seite)</label>
                        <input type="number" id="loadSy" value="0" step="100" onblur="checkEmpty(this)">
                    </div>
                    <div class="input-group">
                        <label>Kraft Sz [N] (Vertikal)</label>
                        <input type="number" id="loadSz" value="10000" step="100" onblur="checkEmpty(this)">
                    </div>
                </div>

                <div class="input-group mb-3">
                    <label>Zusatz-Torsion Mx [Nm]</label>
                    <input type="number" id="loadMx" value="0" step="10" onblur="checkEmpty(this)">
                    <p class="text-xs text-gray-500 mt-1">Reines Moment (zusätzlich zum Hebelarm)</p>
                </div>

                <h4 class="text-sm font-bold text-gray-600 mt-4 mb-2">Kraftangriffspunkt (Relativ zum Schwerpunkt)</h4>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>y_F [mm]</label>
                        <input type="number" id="posFy" value="0" step="10" onblur="checkEmpty(this)">
                    </div>
                    <div class="input-group">
                        <label>z_F [mm]</label>
                        <input type="number" id="posFz" value="0" step="10" onblur="checkEmpty(this)">
                    </div>
                </div>

                <h4 class="text-sm font-bold text-gray-600 mt-4 mb-2">Biegemomente (Für Axialspannung)</h4>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="input-group">
                        <label>My [Nm]</label>
                        <input type="number" id="momentMy" value="5000" step="100" onblur="checkEmpty(this)">
                    </div>
                    <div class="input-group">
                        <label>Mz [Nm]</label>
                        <input type="number" id="momentMz" value="0" step="100" onblur="checkEmpty(this)">
                    </div>
                </div>
            </div>

            <div class="mb-6">
                <button id="updateBtn" onclick="handleUpdateClick()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition shadow-md">
                    Aktualisieren
                </button>
            </div>

        </aside>

        <!-- Visualization Area -->
        <main class="flex-1 flex flex-col relative bg-gray-50">
            <div class="absolute top-4 left-4 bg-white/95 p-3 rounded-lg shadow-md text-xs z-10 pointer-events-none border border-gray-200">
                <div class="font-bold mb-1 text-sm text-gray-800">Koordinatensystem</div>
                <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-black"></span> y: nach rechts</div>
                <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-black"></span> z: nach oben</div>
                <div class="mt-2 text-gray-500 border-t pt-1">Ursprung (0,0) = Flächenschwerpunkt</div>
            </div>

            <!-- Reset View Button -->
            <button onclick="resetView()" class="canvas-overlay-btn" title="Ansicht zurücksetzen">
                ⟲ Ansicht zurücksetzen
            </button>

            <div class="flex-1 p-4 flex justify-center items-center overflow-hidden" id="canvas-container">
                <canvas id="beamCanvas"></canvas>
            </div>

            <!-- Results Footer -->
            <div class="h-auto min-h-[180px] bg-white border-t-2 border-gray-200 p-5 overflow-y-auto shrink-0 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                <h3 class="font-bold text-gray-800 mb-3 text-lg">Berechnungsergebnisse</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 text-sm">
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Geometrie & Trägheit</p>
                        <div class="flex justify-between"><span>Iyy:</span> <span id="resIyy" class="result-val">0</span> <span class="text-gray-400">mm⁴</span></div>
                        <div class="flex justify-between"><span>Izz:</span> <span id="resIzz" class="result-val">0</span> <span class="text-gray-400">mm⁴</span></div>
                        <div class="flex justify-between"><span>Iyz:</span> <span id="resIyz" class="result-val">0</span> <span class="text-gray-400">mm⁴</span></div>
                        <div class="flex justify-between border-t border-gray-100 mt-1 pt-1"><span>Fläche A (Umschlossen):</span> <span id="resArea" class="result-val">0</span> <span class="text-gray-400">mm²</span></div>
                    </div>
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Schubmittelpunkt (SC)</p>
                        <div class="flex justify-between"><span>y_s:</span> <span id="resYs" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                        <div class="flex justify-between"><span>z_s:</span> <span id="resZs" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                    </div>
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Lastsituation</p>
                        <div class="flex justify-between"><span>dy (F zu SC):</span> <span id="resDy" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                        <div class="flex justify-between"><span>dz (F zu SC):</span> <span id="resDz" class="result-val">0</span> <span class="text-gray-400">mm</span></div>
                        <div class="flex justify-between"><span>Torsion (Gesamt):</span> <span id="resTors" class="result-val">0</span> <span class="text-gray-400">Nm</span></div>
                    </div>
                    <div class="space-y-1">
                        <p class="font-semibold text-gray-500 uppercase text-xs tracking-wider">Spitzenwerte</p>
                        <div class="flex justify-between"><span>Max q:</span> <span id="resMaxQ" class="result-val">0</span> <span class="text-gray-400">N/mm</span></div>
                        <div class="flex justify-between"><span>Max σ (Zug):</span> <span id="resMaxTens" class="result-val text-red-600">0</span> <span class="text-gray-400">N/mm²</span></div>
                        <div class="flex justify-between"><span>Max σ (Druck):</span> <span id="resMaxComp" class="result-val text-blue-600">0</span> <span class="text-gray-400">N/mm²</span></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State ---
        const canvas = document.getElementById('beamCanvas');
        const ctx = canvas.getContext('2d');
        let geometry = { 
            booms: [], 
            webs: [], 
            shearFlowPolygons: [], 
            Iyy: 0, Izz: 0, Iyz: 0, 
            centroid: {y:0, z:0}, 
            areaEnclosed: 0,
            isClosed: true
        };
        // View State for Pan/Zoom
        let viewState = {
            zoom: 1.0,
            panX: 0,
            panY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };
        let lastDrawParams = { scale: 1, cx: 0, cy: 0 };
        
        // --- Initialization ---
        window.addEventListener('resize', () => { requestAnimationFrame(resizeCanvas); });
        
        document.addEventListener('DOMContentLoaded', () => {
            updateUI(true); // Initial reset
            resizeCanvas();
        });

        // --- Interaction Handlers (Pan & Zoom) ---
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = 1.1;
            if (e.deltaY < 0) {
                viewState.zoom *= factor;
            } else {
                viewState.zoom /= factor;
            }
            viewState.zoom = Math.max(0.1, Math.min(viewState.zoom, 20));
            requestAnimationFrame(calculateAndDraw);
        });

        canvas.addEventListener('mousedown', (e) => {
            viewState.isDragging = true;
            viewState.lastX = e.clientX;
            viewState.lastY = e.clientY;
            document.body.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', (e) => {
            if (viewState.isDragging) {
                const dx = e.clientX - viewState.lastX;
                const dy = e.clientY - viewState.lastY;
                viewState.panX += dx;
                viewState.panY += dy;
                viewState.lastX = e.clientX;
                viewState.lastY = e.clientY;
                requestAnimationFrame(calculateAndDraw);
                document.getElementById('tooltip').style.display = 'none';
            }
        });

        window.addEventListener('mouseup', () => {
            if(viewState.isDragging) {
                viewState.isDragging = false;
                document.body.style.cursor = 'default';
            }
        });

        function resetView() {
            viewState = { zoom: 1.0, panX: 0, panY: 0, isDragging: false, lastX: 0, lastY: 0 };
            calculateAndDraw();
        }

        // --- Helper: Check Empty Input ---
        function checkEmpty(el) {
            if (el.value.trim() === '') {
                el.value = 0;
                handleUpdateClick(); // Re-calc immediately
            }
        }

        // --- Mouse Interaction for Tooltip ---
        canvas.addEventListener('mousemove', (e) => {
            if (viewState.isDragging || !geometry.booms.length) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const { scale, cx, cy } = lastDrawParams;
            const toX = (val) => cx + val * scale;
            const toY = (val) => cy - val * scale;

            let hit = null;

            // Booms
            for(const b of geometry.booms) {
                const bx = toX(b.y_bar);
                const by = toY(b.z_bar);
                // Hit radius slightly larger for easier clicking if zoomed out
                if (Math.sqrt((x - bx)**2 + (y - by)**2) < 12) {
                    hit = { type: 'boom', data: b }; break; 
                }
            }

            // Polygons
            if (!hit && geometry.shearFlowPolygons) {
                for(const poly of geometry.shearFlowPolygons) {
                    if (pointInPoly(x, y, poly.points)) {
                        hit = { type: 'web', data: poly.data, startId: poly.startId, endId: poly.endId };
                        break;
                    }
                }
            }
            
            // Tooltip
            const tip = document.getElementById('tooltip');
            if (hit) {
                tip.style.display = 'block';
                tip.style.left = (e.clientX + 15) + 'px';
                tip.style.top = (e.clientY + 15) + 'px';
                if (hit.type === 'boom') {
                    const color = hit.data.force >= 0 ? 'text-red-400' : 'text-blue-400';
                    tip.innerHTML = `<div class="font-bold mb-1">Boom ${hit.data.id}</div><div>σ: ${hit.data.sigma.toFixed(2)} N/mm²</div><div>P: <span class="${color}">${hit.data.force.toFixed(1)} N</span></div>`;
                } else {
                    tip.innerHTML = `<div class="font-bold mb-1">Web ${hit.startId}→${hit.endId}</div><div>q: <span class="text-yellow-400">${hit.data.total.toFixed(2)} N/mm</span></div>`;
                }
            } else { tip.style.display = 'none'; }
        });

        function pointInPoly(x, y, vs) {
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].x, yi = vs[i].y;
                const xj = vs[j].x, yj = vs[j].y;
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- UI Logic ---
        function handleUpdateClick() {
            const btn = document.getElementById('updateBtn');
            btn.classList.add('btn-clicked');
            setTimeout(() => btn.classList.remove('btn-clicked'), 200);
            calculateAndDraw();
        }

        function updateUI(reset = false) {
            if(reset) resetView();

            const cat = document.getElementById('shapeType').value;
            const dimsDiv = document.getElementById('dims-container');
            dimsDiv.innerHTML = ''; 

            document.getElementById('sub-closed').classList.add('hidden');
            document.getElementById('sub-open').classList.add('hidden');

            const addInput = (id, label, val) => {
                // Added onblur="checkEmpty(this)"
                dimsDiv.innerHTML += `<div class="input-group"><label>${label} [mm]</label><input type="number" id="${id}" value="${val}" step="10" onblur="checkEmpty(this)"></div>`;
            };

            if (cat === 'closed') {
                document.getElementById('sub-closed').classList.remove('hidden');
                const type = document.getElementById('closedType').value;
                if(type === 'rect' || type === 'ellipse') {
                    // SWAPPED ORDER: Height first, then Width
                    addInput('dimH', 'Höhe h', 500);
                    addInput('dimW', 'Breite w', 1000);
                } else {
                    addInput('dimR', 'Radius R', 400);
                }
            } else {
                document.getElementById('sub-open').classList.remove('hidden');
                const type = document.getElementById('openType').value;
                addInput('dimH', 'Gesamthöhe h', 600);
                
                if (type === 'I') {
                    addInput('dimW_top', 'Breite Oben', 300);
                    addInput('dimW_bot', 'Breite Unten', 300);
                } else if (type === 'C') {
                    addInput('dimW', 'Breite w', 200);
                } else if (type === 'T') {
                    addInput('dimW', 'Breite w', 400); // Renamed label
                } else if (type === 'L') {
                    addInput('dimW', 'Breite w', 300);
                } else if (type === 'Z') {
                    addInput('dimW', 'Breite w', 250);
                }
            }
            setTimeout(calculateAndDraw, 10);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            if(container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                calculateAndDraw();
            }
        }

        // --- Helper for Safer Inputs ---
        function safeFloat(id, defaultVal = 0) {
            const el = document.getElementById(id);
            if (!el || el.value.trim() === '') return defaultVal;
            const val = parseFloat(el.value);
            return isNaN(val) ? defaultVal : val;
        }
        function safeInt(id, defaultVal = 4) {
            const el = document.getElementById(id);
            if (!el || el.value.trim() === '') return defaultVal;
            const val = parseInt(el.value);
            return isNaN(val) ? defaultVal : val;
        }

        // --- Core Logic ---
        function getInputs() {
            return {
                cat: document.getElementById('shapeType').value,
                closedType: document.getElementById('closedType').value,
                openType: document.getElementById('openType').value,
                w: safeFloat('dimW', 1000),
                h: safeFloat('dimH', 500),
                r: safeFloat('dimR', 400),
                w_top: safeFloat('dimW_top', 300),
                w_bot: safeFloat('dimW_bot', 300),
                n: safeInt('numBooms', 16),
                boomArea: safeFloat('boomArea', 200),
                Sy: safeFloat('loadSy', 0),
                Sz: safeFloat('loadSz', 10000),
                Mx: safeFloat('loadMx', 0) * 1000, 
                posFy: safeFloat('posFy', 0),
                posFz: safeFloat('posFz', 0),
                My: safeFloat('momentMy', 5000) * 1000, 
                Mz: safeFloat('momentMz', 0) * 1000, 
            };
        }

        function calculateAndDraw() {
            try {
                const inputs = getInputs();
                generateGeometry(inputs);
                if (geometry.booms.length < 2) return;

                calculateSectionProperties();
                const shearCenter = calculateShearCenter(inputs);
                
                calculateAxialForces(inputs.My, inputs.Mz);
                calculateShearFlows(inputs);

                const leverY = inputs.posFy - shearCenter.y;
                const leverZ = inputs.posFz - shearCenter.z;
                const torsionTotal = (inputs.Sz * leverY) - (inputs.Sy * leverZ) + inputs.Mx;

                updateResults(shearCenter, leverY, leverZ, torsionTotal);
                draw(inputs, shearCenter);
            } catch (e) {
                console.error(e);
            }
        }

        // --- Geometry Generation (Revised for Open Profiles) ---
        function generateGeometry(inputs) {
            geometry.booms = [];
            geometry.webs = [];
            
            const addBoom = (y, z) => {
                const id = geometry.booms.length + 1;
                geometry.booms.push({ id, y, z, area: inputs.boomArea });
                return id - 1; 
            };
            const addWeb = (idx1, idx2) => geometry.webs.push({ startBoom: idx1, endBoom: idx2, total: 0 });
            
            const getLinePoints = (y1, z1, y2, z2, c) => {
                const arr = [];
                for(let i=0; i<c; i++) arr.push({y: y1 + (i/c)*(y2-y1), z: z1 + (i/c)*(z2-z1)});
                return arr;
            };

            if (inputs.cat === 'closed') {
                geometry.isClosed = true;
                const type = inputs.closedType;
                if (type === 'rect' || type === 'ellipse') {
                    const w = inputs.w, h = inputs.h, N = Math.max(4, inputs.n);
                    if(type === 'rect') {
                       const pts = [];
                       pts.push(...getLinePoints(w/2, h/2, -w/2, h/2, N/4)); 
                       pts.push(...getLinePoints(-w/2, h/2, -w/2, -h/2, N/4)); 
                       pts.push(...getLinePoints(-w/2, -h/2, w/2, -h/2, N/4)); 
                       pts.push(...getLinePoints(w/2, -h/2, w/2, h/2, N/4)); 
                       pts.forEach(p => addBoom(p.y, p.z));
                       geometry.areaEnclosed = w * h;
                    } else {
                       const a = w/2, b = h/2;
                       for(let i=0; i<N; i++) {
                           const th = (Math.PI/2) + i * (2*Math.PI/N);
                           addBoom(a*Math.cos(th), b*Math.sin(th));
                       }
                       geometry.areaEnclosed = Math.PI * a * b;
                    }
                } else {
                    const r = inputs.r, N = inputs.n;
                    for(let i=0; i<N; i++) {
                        const th = (Math.PI/2) + i * (2*Math.PI/N);
                        addBoom(r*Math.cos(th), r*Math.sin(th));
                    }
                    let area = 0;
                    for(let i=0; i<N; i++) {
                        const b1 = geometry.booms[i];
                        const b2 = geometry.booms[(i+1)%N];
                        area += (b1.y*b2.z - b1.z*b2.y);
                    }
                    geometry.areaEnclosed = Math.abs(area)/2;
                }
                for(let i=0; i<geometry.booms.length; i++) addWeb(i, (i+1) % geometry.booms.length);
            } else {
                geometry.isClosed = false;
                geometry.areaEnclosed = 0;
                const type = inputs.openType;
                const h = inputs.h;
                
                let nodes = [];
                let connections = []; 
                
                if (type === 'I') {
                    const wt = inputs.w_top, wb = inputs.w_bot;
                    nodes = [
                        {y: -wt/2, z: h/2}, {y: 0, z: h/2}, {y: wt/2, z: h/2}, // Top: TL, TM, TR
                        {y: -wb/2, z: -h/2}, {y: 0, z: -h/2}, {y: wb/2, z: -h/2} // Bot: BL, BM, BR
                    ];
                    connections = [[0,1], [2,1], [3,4], [5,4], [1,4]]; 
                } else if (type === 'T') {
                    const w = inputs.w;
                    nodes = [
                        {y: -w/2, z: h}, {y: 0, z: h}, {y: w/2, z: h},
                        {y: 0, z: 0}
                    ];
                    connections = [[0,1], [2,1], [1,3]];
                } else if (type === 'C') {
                    const w = inputs.w;
                    nodes = [
                        {y: w, z: h/2}, {y: 0, z: h/2},
                        {y: 0, z: -h/2}, {y: w, z: -h/2}
                    ];
                    connections = [[0,1], [1,2], [2,3]];
                } else if (type === 'L') {
                    const w = inputs.w;
                    nodes = [
                        {y: 0, z: h}, {y: 0, z: 0}, {y: w, z: 0}
                    ];
                    connections = [[0,1], [1,2]];
                } else if (type === 'Z') {
                    const w = inputs.w;
                    nodes = [
                        {y: -w, z: h/2}, {y: 0, z: h/2},
                        {y: 0, z: -h/2}, {y: w, z: -h/2}
                    ];
                    connections = [[0,1], [1,2], [2,3]];
                }

                const keyBoomIndices = nodes.map(n => addBoom(n.y, n.z));
                const minBooms = nodes.length;
                const extraBooms = Math.max(0, inputs.n - minBooms);
                
                let totalLen = 0;
                const connLengths = connections.map(c => {
                    const b1 = nodes[c[0]];
                    const b2 = nodes[c[1]];
                    const l = Math.sqrt((b2.y-b1.y)**2 + (b2.z-b1.z)**2);
                    totalLen += l;
                    return l;
                });

                connections.forEach((conn, idx) => {
                    const startIdx = keyBoomIndices[conn[0]];
                    const endIdx = keyBoomIndices[conn[1]];
                    const len = connLengths[idx];
                    const count = Math.round(extraBooms * (len / totalLen));
                    
                    if (count > 0) {
                        let prev = startIdx;
                        const bStart = nodes[conn[0]];
                        const bEnd = nodes[conn[1]];
                        
                        for(let k=1; k<=count; k++) {
                            const t = k / (count + 1);
                            const my = bStart.y + t*(bEnd.y - bStart.y);
                            const mz = bStart.z + t*(bEnd.z - bStart.z);
                            const mid = addBoom(my, mz);
                            addWeb(prev, mid);
                            prev = mid;
                        }
                        addWeb(prev, endIdx);
                    } else {
                        addWeb(startIdx, endIdx);
                    }
                });
            }
        }

        // --- Physics Calculation ---
        function calculateSectionProperties() {
            let sumAy = 0, sumAz = 0, sumA = 0;
            geometry.booms.forEach(b => { sumA += b.area; sumAy += b.area * b.y; sumAz += b.area * b.z; });
            const cy = sumAy / sumA; const cz = sumAz / sumA;
            geometry.centroid = { y: cy, z: cz };
            let Iyy = 0, Izz = 0, Iyz = 0;
            geometry.booms.forEach(b => {
                b.y_bar = b.y - cy; b.z_bar = b.z - cz;
                Iyy += b.area * b.z_bar * b.z_bar; Izz += b.area * b.y_bar * b.y_bar; Iyz += b.area * b.y_bar * b.z_bar;
            });
            geometry.Iyy = Iyy; geometry.Izz = Izz; geometry.Iyz = Iyz;
        }

        function calculateAxialForces(My, MzInput) {
            const Mz = -MzInput; // Fix for coordinate system convention
            const denom = geometry.Iyy * geometry.Izz - geometry.Iyz * geometry.Iyz;
            if (Math.abs(denom) < 1e-9) return; 
            geometry.booms.forEach(b => {
                const sigma = ((My * geometry.Izz - Mz * geometry.Iyz) * b.z_bar + (Mz * geometry.Iyy - My * geometry.Iyz) * b.y_bar) / denom;
                b.sigma = sigma; b.force = sigma * b.area;
            });
        }

        function getDeltaQ(Sy, Sz, boom) {
            const denom = geometry.Iyy * geometry.Izz - geometry.Iyz * geometry.Iyz;
            if (Math.abs(denom) < 1e-9) return 0;
            
            const factorZ = (Sz * geometry.Izz - Sy * geometry.Iyz); // Izz goes with Sz (derivative of My)
            const factorY = (Sy * geometry.Iyy - Sz * geometry.Iyz); // Iyy goes with Sy (derivative of Mz)
            
            return - (factorZ * boom.z_bar + factorY * boom.y_bar) * (boom.area / denom);
        }

        function calculateShearFlows(inputs) {
            const Sy = inputs.Sy; const Sz = inputs.Sz;
            geometry.booms.forEach(b => { b.deltaQ = getDeltaQ(Sy, Sz, b); b.flowIn = 0; });
            geometry.webs.forEach(w => w.total = 0);

            if (geometry.isClosed) {
                let q_curr = 0;
                geometry.webs.forEach(w => {
                    const b = geometry.booms[w.startBoom];
                    q_curr += b.deltaQ;
                    w.total = q_curr; 
                });
                let M_qb = 0;
                geometry.webs.forEach(w => {
                    const b1 = geometry.booms[w.startBoom];
                    const b2 = geometry.booms[w.endBoom];
                    M_qb += w.total * (b1.y_bar * b2.z_bar - b1.z_bar * b2.y_bar);
                });
                const M_ext = Sz * inputs.posFy - Sy * inputs.posFz + inputs.Mx;
                const qs0 = (M_ext - M_qb) / (2 * geometry.areaEnclosed);
                geometry.webs.forEach(w => w.total += qs0);
            } else {
                const incoming = Array(geometry.booms.length).fill().map(() => []);
                const outgoing = Array(geometry.booms.length).fill().map(() => []);
                geometry.webs.forEach((w, idx) => { incoming[w.endBoom].push(idx); outgoing[w.startBoom].push(idx); });
                const inDegree = new Array(geometry.booms.length).fill(0);
                geometry.webs.forEach(w => inDegree[w.endBoom]++);
                const processQ = [];
                for(let i=0; i<geometry.booms.length; i++) if(inDegree[i] === 0) processQ.push(i);
                
                let head = 0;
                while(head < processQ.length) {
                    const u = processQ[head++];
                    let q_in_sum = 0;
                    for(let wIdx of incoming[u]) q_in_sum += geometry.webs[wIdx].total;
                    
                    const q_out_node = q_in_sum + geometry.booms[u].deltaQ;
                    
                    for(let wIdx of outgoing[u]) {
                        geometry.webs[wIdx].total = q_out_node;
                        const v = geometry.webs[wIdx].endBoom;
                        inDegree[v]--;
                        if(inDegree[v] === 0) processQ.push(v);
                    }
                }
            }
        }

        function calculateShearCenter(inputs) {
            if (geometry.isClosed) return {y:0, z:0}; // Valid for symmetric closed sections provided

            const calcMoment = (Sy, Sz) => {
                const localDQs = geometry.booms.map(b => getDeltaQ(Sy, Sz, b));
                const localWebs = geometry.webs.map(w => ({...w, total: 0}));
                const incoming = Array(geometry.booms.length).fill().map(() => []);
                const outgoing = Array(geometry.booms.length).fill().map(() => []);
                localWebs.forEach((w, idx) => { incoming[w.endBoom].push(idx); outgoing[w.startBoom].push(idx); });
                const inDegree = new Array(geometry.booms.length).fill(0);
                localWebs.forEach(w => inDegree[w.endBoom]++);
                const q = [];
                for(let i=0; i<geometry.booms.length; i++) if(inDegree[i]===0) q.push(i);
                let head=0;
                while(head < q.length){
                    const u = q[head++];
                    let q_in = 0;
                    for(let wIdx of incoming[u]) q_in += localWebs[wIdx].total;
                    const q_out = q_in + localDQs[u];
                    for(let wIdx of outgoing[u]) {
                        localWebs[wIdx].total = q_out;
                        const v = localWebs[wIdx].endBoom;
                        inDegree[v]--;
                        if(inDegree[v]===0) q.push(v);
                    }
                }
                let M = 0;
                localWebs.forEach(w => {
                    const b1 = geometry.booms[w.startBoom];
                    const b2 = geometry.booms[w.endBoom];
                    const dA = (b1.y_bar * b2.z_bar - b1.z_bar * b2.y_bar);
                    M += w.total * dA;
                });
                return M;
            };
            const ys = calcMoment(0, 1);
            const zs = -calcMoment(1, 0); 
            return {y: ys, z: zs};
        }

        // --- Drawing with Pan/Zoom support ---
        function draw(inputs, sc) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            geometry.shearFlowPolygons = [];

            // Auto-fit scale if we reset, else maintain viewState relative
            let shapeDim = Math.max(inputs.w || inputs.w_bot || 500, inputs.h);
            const baseScale = Math.min(canvas.width, canvas.height) / (shapeDim * 1.6);
            
            // Apply ViewState
            const currentScale = baseScale * viewState.zoom;
            const cx = (canvas.width / 2) + viewState.panX;
            const cy = (canvas.height / 2) + viewState.panY;

            lastDrawParams = { scale: currentScale, cx: cx, cy: cy };
            const toX = (y) => cx + y * currentScale;
            const toY = (z) => cy - z * currentScale;

            // Skin
            ctx.beginPath();
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            geometry.webs.forEach(w => {
                const b1 = geometry.booms[w.startBoom];
                const b2 = geometry.booms[w.endBoom];
                ctx.moveTo(toX(b1.y_bar), toY(b1.z_bar));
                ctx.lineTo(toX(b2.y_bar), toY(b2.z_bar));
            });
            ctx.stroke();

            // Shear Flow Boxes
            let maxQ = 0;
            geometry.webs.forEach(w => maxQ = Math.max(maxQ, Math.abs(w.total)));
            if (maxQ < 0.001) maxQ = 1;
            
            const maxPx = 50 * viewState.zoom;

            geometry.webs.forEach(w => {
                if (Math.abs(w.total) < 0.001) return;
                const b1 = geometry.booms[w.startBoom];
                const b2 = geometry.booms[w.endBoom];
                const x1 = toX(b1.y_bar), y1 = toY(b1.z_bar);
                const x2 = toX(b2.y_bar), y2 = toY(b2.z_bar);
                
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.sqrt(dx*dx + dy*dy);
                let nx = -dy/len, ny = dx/len;
                
                const mx = (x1+x2)/2, my = (y1+y2)/2;
                if ((mx - cx)*nx + (my - cy)*ny < 0) { nx = -nx; ny = -ny; }

                const h = (Math.abs(w.total) / maxQ) * maxPx;
                const poly = [{x: x1, y: y1}, {x: x2, y: y2}, {x: x2 + nx*h, y: y2 + ny*h}, {x: x1 + nx*h, y: y1 + ny*h}];
                
                geometry.shearFlowPolygons.push({points: poly, data: w, startId: b1.id, endId: b2.id});

                ctx.beginPath();
                ctx.fillStyle = 'rgba(234, 179, 8, 0.4)';
                ctx.strokeStyle = '#eab308';
                ctx.moveTo(poly[0].x, poly[0].y);
                for(let i=1; i<4; i++) ctx.lineTo(poly[i].x, poly[i].y);
                ctx.closePath();
                ctx.fill(); ctx.stroke();

                // Arrow (Scale with Zoom)
                const isPos = w.total >= 0;
                let adx = dx/len, ady = dy/len;
                if(!isPos) { adx = -adx; ady = -ady; }
                
                // Offset Arrow
                // NEW: Constant distance from geometry, scaled by zoom
                const arrowOffsetPx = 5 * viewState.zoom; 
                // Calculate position
                const ax = mx + nx * arrowOffsetPx; 
                const ay = my + ny * arrowOffsetPx;
                
                // Scale Arrow Size
                const arrowLen = 12 * viewState.zoom;
                const headSize = 5 * viewState.zoom;

                // Draw Shaft
                ctx.beginPath(); 
                ctx.strokeStyle = '#f87171'; 
                ctx.lineWidth = 2; 
                ctx.moveTo(ax - adx*(arrowLen/2), ay - ady*(arrowLen/2)); 
                ctx.lineTo(ax + adx*(arrowLen/2), ay + ady*(arrowLen/2));
                ctx.stroke();
                
                // Draw Half-Arrow Head (Asymmetric)
                // Tip position
                const tipX = ax + adx*(arrowLen/2);
                const tipY = ay + ady*(arrowLen/2);
                
                // Base of head on shaft
                const baseX = tipX - adx * headSize;
                const baseY = tipY - ady * headSize;
                
                // Wing tip (outward - using nx, ny which points away from geometry)
                const wingX = baseX + nx * (headSize * 0.8);
                const wingY = baseY + ny * (headSize * 0.8);

                ctx.beginPath();
                ctx.fillStyle = '#f87171'; 
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(baseX, baseY); // Line along shaft (flat side)
                ctx.lineTo(wingX, wingY); // Outward wing
                ctx.closePath();
                ctx.fill();
            });

            // Booms
            let maxSig = 0;
            geometry.booms.forEach(b => maxSig = Math.max(maxSig, Math.abs(b.sigma)));
            if (maxSig === 0) maxSig = 1;

            geometry.booms.forEach(b => {
                const x = toX(b.y_bar), y = toY(b.z_bar);
                // --- SCALING FIX: Apply Zoom to Radius ---
                const r = (3 + (Math.abs(b.sigma)/maxSig)*8) * viewState.zoom;
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2*Math.PI);
                ctx.fillStyle = b.sigma >= 0 ? '#ef4444' : '#3b82f6';
                ctx.fill(); ctx.stroke();

                // Re-add text
                if (r > 6) { 
                    ctx.fillStyle = 'white';
                    // Scale font roughly with zoom but capped
                    const fs = Math.max(8, Math.min(r, 20)); 
                    ctx.font = `bold ${fs}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(b.id, x, y);
                }
            });

            // Markers
            drawCross(cx, cy, 'black', 'CG');
            drawCross(toX(sc.y), toY(sc.z), '#10b981', 'SC');
            
            // Force
            const fx = toX(inputs.posFy), fy = toY(inputs.posFz);
            ctx.beginPath(); ctx.arc(fx, fy, 4, 0, 2*Math.PI); 
            ctx.fillStyle = '#9333ea'; ctx.fill();
            const fMag = Math.sqrt(inputs.Sy**2 + inputs.Sz**2);
            if(fMag > 1) {
                const nSy = inputs.Sy/fMag, nSz = inputs.Sz/fMag;
                ctx.beginPath(); ctx.strokeStyle = '#9333ea'; ctx.lineWidth = 2;
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + nSy*50, fy - nSz*50); 
                ctx.stroke();
            }
        }

        function drawCross(x, y, c, l) {
            ctx.beginPath(); ctx.strokeStyle = c; ctx.lineWidth = 2;
            ctx.moveTo(x-5, y); ctx.lineTo(x+5, y);
            ctx.moveTo(x, y-5); ctx.lineTo(x, y+5);
            ctx.stroke();
            ctx.fillStyle = c; ctx.font = '10px sans-serif'; ctx.fillText(l, x+6, y-6);
        }

        function updateResults(sc, dy, dz, tTot) {
            const fmt = (v) => (isNaN(v)?0:v).toFixed(1);
            const sci = (v) => (isNaN(v)?0:v).toExponential(2);
            document.getElementById('resIyy').innerText = sci(geometry.Iyy);
            document.getElementById('resIzz').innerText = sci(geometry.Izz);
            document.getElementById('resIyz').innerText = sci(geometry.Iyz);
            document.getElementById('resArea').innerText = sci(geometry.areaEnclosed);
            document.getElementById('resYs').innerText = fmt(sc.y);
            document.getElementById('resZs').innerText = fmt(sc.z);
            document.getElementById('resDy').innerText = fmt(dy);
            document.getElementById('resDz').innerText = fmt(dz);
            document.getElementById('resTors').innerText = fmt(tTot/1000);
            let maxQ=0, maxT=0, maxC=0;
            geometry.webs.forEach(w => maxQ = Math.max(maxQ, Math.abs(w.total)));
            geometry.booms.forEach(b => { maxT = Math.max(maxT, b.sigma); maxC = Math.min(maxC, b.sigma); });
            document.getElementById('resMaxQ').innerText = fmt(maxQ);
            document.getElementById('resMaxTens').innerText = fmt(maxT);
            document.getElementById('resMaxComp').innerText = fmt(maxC);
        }
    </script>
</body>
</html>
